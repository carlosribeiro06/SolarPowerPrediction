# -*- coding: utf-8 -*-
"""SolarPowerPrediction

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13wOKlZzeqhvprZur1QWrUTaVhScUAUki
"""

#Importando bibliotecas

import numpy as np
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM
from tensorflow.keras.layers import Dense, Dropout
import pandas as pd
from matplotlib import pyplot as plt
from sklearn.preprocessing import StandardScaler
import seaborn as sns
from sklearn.ensemble import IsolationForest
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split, cross_val_score
import tensorflow as tf
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import *
from tensorflow.keras.callbacks import ModelCheckpoint
from tensorflow.keras.losses import MeanSquaredError
from tensorflow.keras.metrics import RootMeanSquaredError
from tensorflow.keras.optimizers import Adam
import matplotlib.pyplot as plt
from sklearn.covariance import EllipticEnvelope

#Carregando os dados do dataset

dados = pd.read_excel('dataset.xlsx')

#Exibindo parte dos dados

dados

#Verificando dimensões

dados.shape

#Levantamento de dados faltantes

faltantes = dados.isnull().sum()
print(faltantes)

#Atribuindo valores aos dados faltantes encontrados, os substituindo pelo valor médio de cada variável

dados['TEMPERATURA DO PONTO DE ORVALHO (°C)'].fillna(dados['TEMPERATURA DO PONTO DE ORVALHO (°C)'].mean(), inplace=True)
dados['TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)'].fillna(dados['TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)'].mean(), inplace=True)
dados['TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)'].fillna(dados['TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)'].mean(), inplace=True)
dados['UMIDADE REL. MAX. NA HORA ANT. (AUT) (%)'].fillna(dados['UMIDADE REL. MAX. NA HORA ANT. (AUT) (%)'].mean(), inplace=True)
dados['UMIDADE REL. MIN. NA HORA ANT. (AUT) (%)'].fillna(dados['UMIDADE REL. MIN. NA HORA ANT. (AUT) (%)'].mean(), inplace=True)
dados['UMIDADE RELATIVA DO AR, HORARIA (%)'].fillna(dados['UMIDADE RELATIVA DO AR, HORARIA (%)'].mean(), inplace=True)
dados['VENTO, DIREÇÃO HORARIA (gr) (° (gr))'].fillna(dados['VENTO, DIREÇÃO HORARIA (gr) (° (gr))'].mean(), inplace=True)
dados['VENTO, VELOCIDADE HORARIA (m/s)'].fillna(dados['VENTO, VELOCIDADE HORARIA (m/s)'].mean(), inplace=True)

#Verificando os dados faltantes

faltantes = dados.isnull().sum()
print(faltantes)

#Levantamento das informações dos dados

dados.info()

#Retirando a coluna de data e horário do dataframe

date = dados.pop('DATE_TIME')

#Padronizando as variáveis

scaler = StandardScaler()
numericals = ['PRECIPITAÇÃO TOTAL, HORÁRIO (mm)',
       'PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)',
       'PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)',
       'PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)',
       'RADIACAO GLOBAL (Kj/m²)',
       'TEMPERATURA DO AR - BULBO SECO, HORARIA (°C)',
       'TEMPERATURA DO PONTO DE ORVALHO (°C)',
       'TEMPERATURA MÁXIMA NA HORA ANT. (AUT) (°C)',
       'TEMPERATURA MÍNIMA NA HORA ANT. (AUT) (°C)',
       'TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)',
       'TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)',
       'UMIDADE REL. MAX. NA HORA ANT. (AUT) (%)',
       'UMIDADE REL. MIN. NA HORA ANT. (AUT) (%)',
       'UMIDADE RELATIVA DO AR, HORARIA (%)',
       'VENTO, DIREÇÃO HORARIA (gr) (° (gr))', 'VENTO, RAJADA MAXIMA (m/s)',
       'VENTO, VELOCIDADE HORARIA (m/s)', 'val_geracaoprogramada']

dados[numericals] = scaler.fit_transform(dados[numericals])

#Verificando parte dos dados

dados.tail()

#Verificando a nova dimnesão dos dados

dados.shape

#Calculando a correlação entre as variáveis

corr = dados[['PRECIPITAÇÃO TOTAL, HORÁRIO (mm)',
       'PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)',
       'PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)',
       'PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)',
       'RADIACAO GLOBAL (Kj/m²)',
       'TEMPERATURA DO AR - BULBO SECO, HORARIA (°C)',
       'TEMPERATURA DO PONTO DE ORVALHO (°C)',
       'TEMPERATURA MÁXIMA NA HORA ANT. (AUT) (°C)',
       'TEMPERATURA MÍNIMA NA HORA ANT. (AUT) (°C)',
       'TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)',
       'TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)',
       'UMIDADE REL. MAX. NA HORA ANT. (AUT) (%)',
       'UMIDADE REL. MIN. NA HORA ANT. (AUT) (%)',
       'UMIDADE RELATIVA DO AR, HORARIA (%)',
       'VENTO, DIREÇÃO HORARIA (gr) (° (gr))', 'VENTO, RAJADA MAXIMA (m/s)',
       'VENTO, VELOCIDADE HORARIA (m/s)', 'val_geracaoprogramada']].corr()

#Exibindo os valores calculados de correlação

display(corr['val_geracaoprogramada'])

#Plotando mapa de calor da correlação

plt.figure(figsize=(20, 10))
plt.style.use('ggplot')
sns.heatmap(corr, cmap='RdBu', fmt='.2f', square=True, linecolor='white', annot=True)
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)
plt.savefig("Correlation.png", dpi=300)

#Fazendo o levantamento de outliers das variáveis e plotando os gráficos

dt_mean, dt_std = np.mean(dados['PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)']), np.std(dados['PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)'])
cut_off = dt_std*3
lower, upper = dt_mean - cut_off, dt_mean + cut_off
idx = np.where((dados['PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)'] < lower) | (dados['PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)'] > upper))

i = dados['PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)'][idx[0]]
print(i)

sns.scatterplot(data=dados, x="PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)", y="val_geracaoprogramada", color='red')
sns.scatterplot(data=dados[2563:2564], x="PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4764:4765], x="PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4787:4791], x="PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4811:4816], x="PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4834:4839], x="PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4884:4885], x="PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4908:4909], x="PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5076:5078], x="PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5100:5101], x="PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7315:7316], x="PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)", y="val_geracaoprogramada", color='blue')
plt.legend(labels=["Normal", "Outlier"], loc='upper right', prop={'size':10})

dt_mean, dt_std = np.mean(dados['PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)']), np.std(dados['PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)'])
cut_off = dt_std*3
lower, upper = dt_mean - cut_off, dt_mean + cut_off
idx = np.where((dados['PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)'] < lower) | (dados['PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)'] > upper))

i = dados['PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)'][idx[0]]
print(i)

sns.scatterplot(data=dados, x="PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='red')
sns.scatterplot(data=dados[2563:2564], x="PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4787:4792], x="PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4811:4817], x="PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4835:4840], x="PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4908:4910], x="PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5076:5077], x="PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7220:7221], x="PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7315:7318], x="PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[8324:8325], x="PRESSÃO ATMOSFERICA MAX.NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
plt.legend(labels=["Normal", "Outlier"], loc='upper right', prop={'size':10})

dt_mean, dt_std = np.mean(dados['PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)']), np.std(dados['PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)'])
cut_off = dt_std*3
lower, upper = dt_mean - cut_off, dt_mean + cut_off
idx = np.where((dados['PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)'] < lower) | (dados['PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)'] > upper))

i = dados['PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)'][idx[0]]
print(i)

sns.scatterplot(data=dados, x="PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='red')
sns.scatterplot(data=dados[4765:4766], x="PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4787:4791], x="PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4811:4816], x="PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4835:4839], x="PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4884:4886], x="PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4908:4910], x="PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5077:5078], x="PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5100:5102], x="PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7315:7318], x="PRESSÃO ATMOSFERICA MIN. NA HORA ANT. (AUT) (mB)", y="val_geracaoprogramada", color='blue')
plt.legend(labels=["Normal", "Outlier"], loc='upper right', prop={'size':10})

dt_mean, dt_std = np.mean(dados['TEMPERATURA DO PONTO DE ORVALHO (°C)']), np.std(dados['TEMPERATURA DO PONTO DE ORVALHO (°C)'])
cut_off = dt_std*3
lower, upper = dt_mean - cut_off, dt_mean + cut_off
idx = np.where((dados['TEMPERATURA DO PONTO DE ORVALHO (°C)'] < lower) | (dados['TEMPERATURA DO PONTO DE ORVALHO (°C)'] > upper))

i = dados['TEMPERATURA DO PONTO DE ORVALHO (°C)'][idx[0]]
print(i)

sns.scatterplot(data=dados, x="TEMPERATURA DO PONTO DE ORVALHO (°C)", y="val_geracaoprogramada", color='red')
sns.scatterplot(data=dados[5301:5302], x="TEMPERATURA DO PONTO DE ORVALHO (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5924:5925], x="TEMPERATURA DO PONTO DE ORVALHO (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6932:6935], x="TEMPERATURA DO PONTO DE ORVALHO (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6954:6966], x="TEMPERATURA DO PONTO DE ORVALHO (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7003:7004], x="TEMPERATURA DO PONTO DE ORVALHO (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7268:7270], x="TEMPERATURA DO PONTO DE ORVALHO (°C)", y="val_geracaoprogramada", color='blue')
plt.legend(labels=["Normal", "Outlier"], loc='upper left', prop={'size':10})

dt_mean, dt_std = np.mean(dados['TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)']), np.std(dados['TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)'])
cut_off = dt_std*3
lower, upper = dt_mean - cut_off, dt_mean + cut_off
idx = np.where((dados['TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)'] < lower) | (dados['TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)'] > upper))

i = dados['TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)'][idx[0]]
print(i)

sns.scatterplot(data=dados, x="TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='red')
sns.scatterplot(data=dados[5302:5303], x="TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5925:5926], x="TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6933:6938], x="TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6954:6966], x="TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7003:7006], x="TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7268:7270], x="TEMPERATURA ORVALHO MAX. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='blue')
plt.legend(labels=["Normal", "Outlier"], loc='upper left', prop={'size':10})

dt_mean, dt_std = np.mean(dados['TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)']), np.std(dados['TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)'])
cut_off = dt_std*3
lower, upper = dt_mean - cut_off, dt_mean + cut_off
idx = np.where((dados['TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)'] < lower) | (dados['TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)'] > upper))

i = dados['TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)'][idx[0]]
print(i)

sns.scatterplot(data=dados, x="TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='red')
sns.scatterplot(data=dados[5924:5925], x="TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6932:6936], x="TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6953:6965], x="TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7002:7004], x="TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7269:7271], x="TEMPERATURA ORVALHO MIN. NA HORA ANT. (AUT) (°C)", y="val_geracaoprogramada", color='blue')
plt.legend(labels=["Normal", "Outlier"], loc='upper left', prop={'size':10})

dt_mean, dt_std = np.mean(dados['VENTO, RAJADA MAXIMA (m/s)']), np.std(dados['VENTO, RAJADA MAXIMA (m/s)'])
cut_off = dt_std*3
lower, upper = dt_mean - cut_off, dt_mean + cut_off
idx = np.where((dados['VENTO, RAJADA MAXIMA (m/s)'] < lower) | (dados['VENTO, RAJADA MAXIMA (m/s)'] > upper))

i = dados['VENTO, RAJADA MAXIMA (m/s)'][idx[0]]
print(i)

sns.scatterplot(data=dados, x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='red')
sns.scatterplot(data=dados[165:166], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[1123:1124], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[1394:1396], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[3211:3212], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4838:4840], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5460:5461], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5480:5481], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5706:5707], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5990:5992], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6060:6061], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7194:7196], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7291:7292], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[8321:8322], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[8662:8663], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[8977:8979], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[9046:9047], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[9354:9355], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[10051:10053], x="VENTO, RAJADA MAXIMA (m/s)", y="val_geracaoprogramada", color='blue')
plt.legend(labels=["Normal", "Outlier"], loc='upper right', prop={'size':10})

dt_mean, dt_std = np.mean(dados['VENTO, VELOCIDADE HORARIA (m/s)']), np.std(dados['VENTO, VELOCIDADE HORARIA (m/s)'])
cut_off = dt_std*3
lower, upper = dt_mean - cut_off, dt_mean + cut_off
idx = np.where((dados['VENTO, VELOCIDADE HORARIA (m/s)'] < lower) | (dados['VENTO, VELOCIDADE HORARIA (m/s)'] > upper))

i = dados['VENTO, VELOCIDADE HORARIA (m/s)'][idx[0]]
#np.array(i)
np.array(i.index)

sns.scatterplot(data=dados, x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='red')
sns.scatterplot(data=dados[64:65], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[616:617], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[2675:2676], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[2677:2678], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[3996:3997], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4117:4118], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4140:4141], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4260:4261], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4332:4333], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4444:4445], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4451:4453], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4454:4455], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4476:4477], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4715:4719], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4814:4815], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4838:4839], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4861:4862], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4864:4865], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4884:4885], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[4908:4909], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5027:5028], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5123:5124], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5291:5292], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5293:5294], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5339:5340], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5435:5436], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5460:5462], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5483:5487], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5507:5508], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5963:5964], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[5987:5991], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6012:6013], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6059:6061], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6085:6086], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6134:6135], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6226:6228], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6299:6300], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6637:6638], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6803:6804], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6947:6948], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[6970:6971], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7166:7167], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7194:7195], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[7475:7476], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[8082:8083], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[8661:8662], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[8977:8978], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
sns.scatterplot(data=dados[10051:10052], x="VENTO, VELOCIDADE HORARIA (m/s)", y="val_geracaoprogramada", color='blue')
plt.legend(labels=["Normal", "Outlier"], loc='upper right', prop={'size':10})

#Retirando as variáveis que apresentaram correlação negativa com a variável alvo

waste2 = dados.pop('PRECIPITAÇÃO TOTAL, HORÁRIO (mm)')
waste3 = dados.pop('TEMPERATURA DO AR - BULBO SECO, HORARIA (°C)')
waste4 = dados.pop('TEMPERATURA MÁXIMA NA HORA ANT. (AUT) (°C)')
waste5 = dados.pop('TEMPERATURA MÍNIMA NA HORA ANT. (AUT) (°C)')
waste6 = dados.pop('VENTO, DIREÇÃO HORARIA (gr) (° (gr))')
X = dados

#Verificando a dimensão dos dados

dados.shape

#Verificando a quantidade de outliers

out_IF = IsolationForest(contamination=0.1).fit_predict(X.values)

outliers = X.values[out_IF != 1, :]
X_out = X.values[out_IF != -1, :]

print('Número de outliers: %i' % outliers.shape[0])
print('\nDados sem outliers')
print('Número de variáveis: %i' % outliers.shape[1])
print('Número de amostras: %i' % outliers.shape[0])

#Exibindo os dados

X.head()

#Coletando o a lista com os labels de cada coluna

cols = list(X)[1:13]

#Imprimindo a variável anterior

print(cols)

#Criando um dataframe para essas variáveis

df_for_training = X[cols].astype(float)

#Separando os dados

X = []
y = []

n_future = 1   #Número de dias a ser verificado com base nos dias anteriores
n_past = 1  #Número de dias no passado usado para prever o futuro

for i in range(n_past, len(df_for_training) - n_future +1):
    X.append(df_for_training.iloc[i - n_past:i, 0:df_for_training.shape[1]])
    y.append(df_for_training.iloc[i + n_future - 1:i + n_future, 11:12])
X, y = np.array(X), np.array(y)

print('X shape == {}.'.format(X.shape))
print('y shape == {}.'.format(y.shape))

#Separando dados em treinamento e teste

X_train =  X[0:9504]
X_test = X[9504:10200]
y_train = y[0:9504]
y_test = y[9504:10200]

#Rede neural

model = Sequential()
model.add(LSTM(64, activation='relu', input_shape=(X.shape[1], X.shape[2]), return_sequences=True))
model.add(LSTM(32, activation='relu', return_sequences=False))
model.add(Dropout(0.2))
model.add(Dense(1))

cp = ModelCheckpoint('model/', save_best_only=True)
model.compile(optimizer=Adam(learning_rate=0.001), loss='mae', metrics='mae')
model.summary()

#Treinando o modelo
#Nessa etapa vale destacar que o conjunto de treinamento está sendo dividido em treino e validação, onde a validação corresponderá 10% dos dados de treinamento
#Vale destacar também que apenas o modelo com melhor resultado na validação será salvo

history = model.fit(X_train, y_train, epochs=100, batch_size=16, validation_split=0.1, verbose=1, callbacks=[cp])

#Plotando gráfico da Loss Function com o passar das épocas

plt.plot(history.history['loss'], label='Training loss')
plt.plot(history.history['val_loss'], label='Validation loss')
plt.legend()

#Avaliação do desempenho do modelo

model.evaluate(X_test, y_test)

#Utilizando os dados de teste para fazer previsões

test_predictions = model.predict(X_test).flatten()
test_results = pd.DataFrame(data={'Test Predictions':test_predictions, 'Actuals':y_test.flatten()})
test_results

#Colocando as datas e horários da base de treinamento como índice

test_results.index = pd.to_datetime(date[9504:10199], format='%d.%m.%Y %H:%M:%S')

#Exibindo os resultados

test_results

#Plotando a previsão da geração junto da base original para verificar o desempenho do modelo

plt.figure(figsize=(30, 5))
plt.plot(test_results['Actuals'], label='Original data')
plt.plot(test_results['Test Predictions'], label='Prediction')
plt.title('Previsão da geração programada')
plt.legend(loc='upper right', prop={'size':8})
plt.xticks(rotation=45)
plt.savefig("Prediction.png", dpi=300)
plt.show()

plt.plot(test_results['Actuals'][0:25], label='Original data')
plt.plot(test_results['Test Predictions'][0:25], label='Prediction')
plt.title('Previsão da geração programada')
plt.legend(loc='upper right', prop={'size':8})
plt.xticks(rotation=45)
plt.show()

plt.plot(test_results['Actuals'][0:50], label='Original data')
plt.plot(test_results['Test Predictions'][0:50], label='Prediction')
plt.title('Previsão da geração programada')
plt.legend(loc='best', prop={'size':8})
plt.xticks(rotation=45)
plt.show()

plt.plot(test_results['Actuals'][0:75], label='Original data')
plt.plot(test_results['Test Predictions'][0:75], label='Prediction')
plt.title('Previsão da geração programada')
plt.legend(loc='upper right', prop={'size':8})
plt.xticks(rotation=45)
plt.show()

plt.plot(test_results['Actuals'][0:100], label='Original data')
plt.plot(test_results['Test Predictions'][0:100], label='Prediction')
plt.title('Previsão da geração programada')
plt.legend(loc='best', prop={'size':8})
plt.xticks(rotation=45)
plt.show()